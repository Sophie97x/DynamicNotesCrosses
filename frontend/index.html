<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>XO</title>
<link rel="icon" type="image/svg+xml" href="favicon.svg">
<link rel="icon" type="image/png" href="favicon.png">
<style>
:root {
  --grid-size: min(80vw, 400px);
  --cell-size: calc(var(--grid-size) / 3.5);
  --primary-color: #00ff00;
  --primary-glow: 0 0 10px var(--primary-color);
  --intense-glow: 0 0 10px var(--primary-color), 0 0 20px var(--primary-color);
}

body {
  font-family: Arial, sans-serif;
  text-align: center;
  margin: 0;
  padding: 0 10px;
  padding-bottom: 60px; /* Space for footer */
  min-height: 100vh;
  background-color: #000;
  color: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
}

h1 {
  margin-top: 20px;
  margin-bottom: 20px;
  color: var(--primary-color);
  text-shadow: var(--intense-glow);
  font-size: clamp(24px, 5vw, 36px);
}
#modeSelect {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  justify-content: center;
  margin: 10px auto;
  max-width: var(--grid-size);
}

#modeSelect button,
.action-btn,
.home-button {
  padding: 10px 20px;
  font-size: clamp(14px, 3vw, 16px);
  background-color: var(--primary-color);
  color: #000;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  box-shadow: var(--primary-glow);
  white-space: nowrap;
  min-width: 120px;
}

.home-button {
  position: fixed;
  top: 20px;
  left: 20px;
  z-index: 1000;
  min-width: unset;
}

@media (max-width: 600px) {
  .home-button {
    position: static;
    margin: 10px auto;
  }
}

.home-button:hover,
#modeSelect button:hover,
.action-btn:hover {
  background-color: #004d00;
  color: #fff;
}

.room-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  justify-content: center;
  margin: 10px;
}

.room-join-container {
  display: none;
  gap: 10px;
  justify-content: center;
  margin: 10px;
  flex-wrap: wrap;
}
.room-code-input {
  padding: 10px;
  font-size: 16px;
  border: 2px solid #00ff00;
  border-radius: 5px;
  background: #111;
  color: #00ff00;
  outline: none;
}
.room-code-input:focus {
  box-shadow: 0 0 10px #00ff00;
}
.start-button {
  padding: 10px 20px;
  font-size: 16px;
  background-color: #00ff00;
  color: #000;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  box-shadow: 0 0 10px #00ff00;
}
.start-button:hover {
  background-color: #004d00;
  color: #fff;
}
.room-code-display {
  margin: 10px;
  padding: 10px;
  background: #111;
  border: 1px solid #00ff00;
  border-radius: 5px;
  display: inline-block;
}
.grid {
  display: grid;
  grid-template-columns: repeat(3, var(--cell-size));
  gap: min(15px, 3vw);
  margin: 20px auto;
  width: var(--grid-size);
}

.cell {
  width: var(--cell-size);
  height: var(--cell-size);
  background: linear-gradient(145deg, #111, #222);
  border: 2px solid var(--primary-color);
  border-radius: min(10px, 2vw);
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: clamp(24px, 8vw, 40px);
  font-weight: bold;
  color: var(--primary-color);
  text-shadow: var(--intense-glow);
  cursor: pointer;
  box-shadow: var(--primary-glow), inset 0 0 10px #004d00;
  transition: all 0.3s ease;
}
.cell:hover {
  background: #004d00;
  box-shadow: 0 0 20px #00ff00, inset 0 0 15px #00ff00;
}
.cell.faded {
  opacity: 0.5;
  text-shadow: 0 0 5px #00ff00;
}
.cell.empty {
  color: transparent;
  text-shadow: none;
}
.win-screen {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  color: #00ff00;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  z-index: 1000;
  text-align: center;
}
.win-screen h2 {
  font-size: 50px;
  margin-bottom: 20px;
  text-shadow: 0 0 15px #00ff00;
}
.win-screen button {
  padding: 10px 20px;
  font-size: 20px;
  color: #000;
  background-color: #00ff00;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  box-shadow: 0 0 10px #00ff00;
}
.win-screen button:hover {
  background-color: #004d00;
  color: #fff;
}
.footer {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  padding: 15px;
  background-color: rgba(0, 0, 0, 0.9);
  color: var(--primary-color);
  text-align: center;
  font-size: clamp(12px, 2.5vw, 14px);
  text-shadow: var(--primary-glow);
  backdrop-filter: blur(5px);
  z-index: 1000;
  line-height: 1.5;
  transition: opacity 0.5s ease-in-out;
}
.footer.hidden {
  opacity: 0;
  pointer-events: none;
}
.grid.disabled {
  pointer-events: none;
}
</style>
</head>
<body>
<button class="home-button" onclick="goHome()">Home</button>
<h1>Dynamic Notes and Crosses</h1>
<div id="modeSelect">
  <button onclick="selectMode('local')">Local 2-Player</button>
  <button onclick="selectMode('ai')">Play vs AI</button>
  <button onclick="selectMode('online')">Online Multiplayer</button>
</div>

<div id="aiSettings" style="display:none; margin:10px;">
  <label>AI Difficulty: 
    <select id="aiDifficulty">
      <option value="easy">Easy</option>
      <option value="medium">Medium</option>
      <option value="hard">Hard</option>
    </select>
  </label>
  <button onclick="startAIGame()">Start Game</button>
</div>

<div id="onlineSettings" style="display:none; margin:10px;">
  <div class="room-buttons">
    <button onclick="findRandomMatch()" class="action-btn">Find Random Match</button>
    <button onclick="createRoom()" class="action-btn">Create Room</button>
    <button onclick="showJoinRoom()" class="action-btn">Join Room</button>
  </div>
  <div id="roomCodeDisplay" class="room-code-display" style="display:none">
    Room Code: <span id="displayedRoomCode"></span>
    <button onclick="copyRoomCode()" class="action-btn">Copy Code</button>
  </div>
  <div id="joinRoomPanel" class="room-join-container">
    <input type="text" class="room-code-input" id="roomCodeInput" placeholder="Enter Room Code">
    <button class="start-button" onclick="joinRoom()">Start</button>
  </div>
  <span id="queueInfo"></span>
  <div id="onlineStatus" style="margin-top:10px;">
    <div>Players Online: <span id="playersOnline">0</span></div>
    <div>In Queue: <span id="playersInQueue">0</span></div>
    <div id="roomInfo"></div>
  </div>
</div>

<div id="gameContainer">
    <div id="turnIndicator" style="display: none; margin-bottom: 10px;"></div>
    <div class="grid" id="gameGrid">
      <div class="cell empty" data-cell></div>
      <div class="cell empty" data-cell></div>
      <div class="cell empty" data-cell></div>
      <div class="cell empty" data-cell></div>
      <div class="cell empty" data-cell></div>
      <div class="cell empty" data-cell></div>
      <div class="cell empty" data-cell></div>
      <div class="cell empty" data-cell></div>
      <div class="cell empty" data-cell></div>
    </div>
</div>
<div class="win-screen" id="winScreen" style="display: none; flex-direction: column;">
  <h2 id="winnerText"></h2>
  <button onclick="restartGame()">Restart</button>
</div>
<div id="onlineUI" style="display:none; margin:10px;">
  <button onclick="findRandomMatch()">Random Match</button>
  <input id="roomInput" placeholder="Room ID" style="width:100px;"/>
  <button onclick="joinRoom()">Join Room</button>
  <div id="onlineStatus"></div>
  <div id="queueInfo"></div>
  <div id="roomInfo"></div>
</div>
<script>
// Game state
let board = Array(9).fill(null);
let moveHistory = [];
let moveCount = 0;
let currentMode = null;
let currentTurn = 'X';
let socket = null;
let roomCode = null;
let playerMark = null; // 'X' or 'O' in multiplayer

// DOM elements
const grid = document.getElementById('gameGrid');
const cells = Array.from(document.querySelectorAll('[data-cell]'));
const winScreen = document.getElementById('winScreen');
const winnerText = document.getElementById('winnerText');
const modeSelect = document.getElementById('modeSelect');
const aiSettings = document.getElementById('aiSettings');
const onlineSettings = document.getElementById('onlineSettings');
const queueInfo = document.getElementById('queueInfo');
const playersOnline = document.getElementById('playersOnline');
const playersInQueue = document.getElementById('playersInQueue');
const roomInfo = document.getElementById('roomInfo');
const turnIndicator = document.getElementById('turnIndicator');

// Game logic
function selectMode(mode) {
    currentMode = mode;
    modeSelect.style.display = 'none';
    aiSettings.style.display = 'none';
    onlineSettings.style.display = 'none';
    
    if (mode === 'local') {
        document.getElementById('gameContainer').style.display = 'block';
        setupLocalGame();
    } else if (mode === 'ai') {
        aiSettings.style.display = 'block';
    } else if (mode === 'online') {
        onlineSettings.style.display = 'block';
        document.getElementById('gameContainer').style.display = 'block';
        setupOnlineGame();
    }
}

function setupLocalGame() {
    resetGame();
    currentTurn = 'X';
    cells.forEach(cell => {
        cell.addEventListener('click', handleLocalMove);
    });
}

function setupAIGame(difficulty) {
    resetGame();
    currentTurn = 'X';
    cells.forEach(cell => {
        cell.addEventListener('click', handlePlayerVsAIMove);
    });
}

function setupOnlineGame() {
    resetGame();
    
    // Clean up any existing socket
    if (socket) {
        socket.close();
        socket = null;
    }
    
    // Connect to WebSocket with Safari compatibility
    const wsUrl = `${window.location.origin.replace(/^http/, 'ws')}/ws`;
    console.log('Connecting to WebSocket at:', wsUrl);
    
    // Add connection timeout
    const connectTimeout = setTimeout(() => {
        console.error('WebSocket connection timed out');
        roomInfo.textContent = 'Connection timed out. Please try again.';
    }, 5000);
    
    try {
        socket = new WebSocket(wsUrl);
        
        // Force binary type to arraybuffer for Safari compatibility
        socket.binaryType = 'arraybuffer';
        
        // Add error handling for connection issues
        socket.addEventListener('error', (error) => {
            console.error('WebSocket error:', error);
            roomInfo.textContent = 'Connection error. Please try again.';
            clearTimeout(connectTimeout);
        });
        
        socket.addEventListener('open', () => {
            clearTimeout(connectTimeout);
            console.log('WebSocket connected successfully');
            roomInfo.textContent = 'Connected to server';
        });
        
    } catch (err) {
        console.error('WebSocket creation failed:', err);
        roomInfo.textContent = 'Failed to connect to game server. Please try again.';
        clearTimeout(connectTimeout);
    }
    
    socket.onopen = () => {
        console.log('Connected to game server');
        roomInfo.textContent = 'Connected to server';
        // Request initial stats
        socket.send(JSON.stringify({ type: 'getStats' }));
    };
    
    // Reset game state
    currentTurn = 'X';
    playerMark = null; // Will be set when matched
    
    socket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        handleServerMessage(data);
    };
    
    socket.onclose = () => {
        roomInfo.textContent = 'Disconnected from server';
    };

    // Request available rooms when socket connects
    socket.onopen = () => {
        socket.send(JSON.stringify({ type: 'getRooms' }));
    };
}

function handleServerMessage(data) {
    switch(data.type) {
        case 'stats':
            playersOnline.textContent = data.playersOnline;
            playersInQueue.textContent = data.playersInQueue;
            break;
        case 'matched':
            roomCode = data.roomCode;
            playerMark = data.playerMark;
            currentTurn = 'X'; // Always start with X
            
            // Hide settings
            document.getElementById('onlineSettings').style.display = 'none';
            
            updateTurnIndicator();
            
            // Add click handlers for online play
            cells.forEach(cell => cell.addEventListener('click', handleOnlineMove));
            break;
        case 'roomCreated':
            roomCode = data.roomCode;
            document.getElementById('displayedRoomCode').textContent = roomCode;
            document.getElementById('roomCodeDisplay').style.display = 'inline-block';
            queueInfo.textContent = 'Waiting for opponent to join...';
            break;
        case 'availableRooms':
            updateAvailableRooms(data.rooms);
            break;
        case 'gameState':
            board = data.board;
            currentTurn = data.currentTurn;
            updateBoard(data.fadingPiece);
            updateTurnIndicator();
            break;
        case 'move':
            handleOpponentMove(data.position);
            break;
        case 'queue':
            queueInfo.textContent = 'Waiting for opponent...';
            break;
        case 'roomFull':
            queueInfo.textContent = 'Room is full. Please try another room.';
            break;
        case 'gameOver':
            if (data.winner === 'draw') {
                winnerText.textContent = "It's a Draw!";
            } else {
                winnerText.textContent = `${data.winner} Wins!`;
            }
            winScreen.style.display = 'flex';
            break;
    }
}

function updateTurnIndicator() {
    turnIndicator.style.display = 'block';
    if (playerMark) {
        turnIndicator.textContent = `You are ${playerMark}. It's ${currentTurn}'s turn.`;
    } else {
        turnIndicator.textContent = `It's ${currentTurn}'s turn.`;
    }

    if (currentTurn === playerMark) {
        grid.classList.remove('disabled');
    } else {
        grid.classList.add('disabled');
    }
}

function updateBoard(fadingPiece) {
    // First, clear all 'faded' classes
    cells.forEach(cell => cell.classList.remove('faded'));

    board.forEach((mark, index) => {
        const cell = cells[index];
        cell.textContent = mark;
        if (mark) {
            cell.classList.remove('empty');
        } else {
            cell.classList.add('empty');
        }
    });

    // Apply 'faded' class to the specific piece
    if (fadingPiece !== null && fadingPiece >= 0) {
        cells[fadingPiece].classList.add('faded');
    }
}

function updateAvailableRooms(rooms) {
    console.log("Available rooms:", rooms);
    // In the future, you could display these rooms in the UI.
}

function handleLocalMove(e) {
    const cell = e.target;
    const index = cells.indexOf(cell);
    
    if (cell.textContent || !cell.classList.contains('empty')) return;
    
    moveCount++;
    currentTurn = moveCount % 2 === 0 ? 'O' : 'X';
    board[index] = currentTurn;
    placeMark(cell, currentTurn);
    
    // Update display
    cell.textContent = mark;
    cell.classList.remove('empty');
    
    // Handle history
    moveHistory.push(index);
    if (moveHistory.length >= 5) {
        const fadeIndex = moveHistory[moveHistory.length - 5];
        if (fadeIndex >= 0) {
            cells[fadeIndex].classList.add('faded');
        }
    }
    if (moveHistory.length >= 6) {
        const oldestIndex = moveHistory.shift();
        board[oldestIndex] = null;
        cells[oldestIndex].textContent = '';
        cells[oldestIndex].classList.remove('faded');
        cells[oldestIndex].classList.add('empty');
    }
    
    checkWin();
}

function checkWin() {
    const winningCombos = [
        [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
        [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
        [0, 4, 8], [2, 4, 6] // diagonals
    ];
    
    for (const combo of winningCombos) {
        const [a, b, c] = combo;
        if (board[a] && board[a] === board[b] && board[a] === board[c]) {
            showWin(board[a]);
            return;
        }
    }
}

function showWin(winner) {
    winnerText.textContent = `${winner} Wins!`;
    winScreen.style.display = 'flex';
}

function resetGame() {
    board = Array(9).fill(null);
    moveHistory = [];
    moveCount = 0;
    cells.forEach(cell => {
        cell.textContent = '';
        cell.classList.remove('faded');
        cell.classList.add('empty');
    });
    winScreen.style.display = 'none';
    turnIndicator.style.display = 'none';
}

// AI Game Logic
function handlePlayerVsAIMove(e) {
    if (currentTurn !== 'X') return; // Wait for player's turn
    
    const cell = e.target;
    const index = cells.indexOf(cell);
    
    if (cell.textContent || !cell.classList.contains('empty')) return;
    
    // Player move
    board[index] = 'X';
    placeMark(cell, 'X');
    currentTurn = 'O';
    
    if (!checkWin()) {
        // AI move
        setTimeout(() => {
            const aiMove = calculateAIMove(board, aiDifficulty.value);
            board[aiMove] = 'O';
            placeMark(cells[aiMove], 'O');
            currentTurn = 'X';
            checkWin();
        }, 500);
    }
}

function calculateAIMove(board, difficulty) {
    if (difficulty === 'easy') {
        // Random empty spot
        const emptyCells = board.map((val, idx) => val ? null : idx).filter(val => val !== null);
        return emptyCells[Math.floor(Math.random() * emptyCells.length)];
    } else if (difficulty === 'medium') {
        // Block winning moves or take winning moves, otherwise random
        const winMove = findWinningMove(board, 'O');
        if (winMove !== null) return winMove;
        
        const blockMove = findWinningMove(board, 'X');
        if (blockMove !== null) return blockMove;
        
        return calculateAIMove(board, 'easy');
    } else {
        // Hard: Use minimax
        return findBestMove(board);
    }
}

function findWinningMove(board, mark) {
    for (let i = 0; i < 9; i++) {
        if (!board[i]) {
            board[i] = mark;
            if (checkWinCondition(board)) {
                board[i] = null;
                return i;
            }
            board[i] = null;
        }
    }
    return null;
}

function findBestMove(board) {
    let bestScore = -Infinity;
    let bestMove = null;
    
    for (let i = 0; i < 9; i++) {
        if (!board[i]) {
            board[i] = 'O';
            let score = minimax(board, 0, false);
            board[i] = null;
            if (score > bestScore) {
                bestScore = score;
                bestMove = i;
            }
        }
    }
    
    return bestMove;
}

function minimax(board, depth, isMaximizing) {
    if (checkWinCondition(board)) {
        return isMaximizing ? -1 : 1;
    }
    if (isBoardFull(board)) {
        return 0;
    }
    
    if (isMaximizing) {
        let bestScore = -Infinity;
        for (let i = 0; i < 9; i++) {
            if (!board[i]) {
                board[i] = 'O';
                let score = minimax(board, depth + 1, false);
                board[i] = null;
                bestScore = Math.max(score, bestScore);
            }
        }
        return bestScore;
    } else {
        let bestScore = Infinity;
        for (let i = 0; i < 9; i++) {
            if (!board[i]) {
                board[i] = 'X';
                let score = minimax(board, depth + 1, true);
                board[i] = null;
                bestScore = Math.min(score, bestScore);
            }
        }
        return bestScore;
    }
}

// Online Game Logic
function findRandomMatch() {
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ type: 'queue' }));
        queueInfo.textContent = 'Finding a match...';
    }
}

function joinRoom() {
    const code = document.getElementById('roomCode').value;
    if (code && socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ type: 'join', roomCode: code }));
        roomInfo.textContent = 'Joining room...';
    }
}

function handleOnlineMove(e) {
    if (currentTurn !== playerMark) return; // Not your turn

    const cell = e.target;
    const index = cells.indexOf(cell);

    if (board[index] !== null) return; // Cell already taken

    // Send move to server
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
            type: 'move',
            roomCode: roomCode,
            position: index
        }));
    }
}

function handleOpponentMove(position) {
    if (position >= 0 && position < 9 && cells[position].classList.contains('empty')) {
        const opponentMark = currentTurn;  // Use currentTurn as that's the current player's mark
        board[position] = opponentMark;
        placeMark(cells[position], opponentMark);
        currentTurn = currentTurn === 'X' ? 'O' : 'X';
        roomInfo.textContent = `Room: ${roomCode} - You are ${playerMark} - ${currentTurn}'s Turn`;
        turnIndicator.textContent = `${currentTurn}'s Turn`;
        checkWin();
    }
}

// UI Helpers
function startAIGame() {
    document.getElementById('gameContainer').style.display = 'block';
    const difficulty = document.getElementById('aiDifficulty').value;
    setupAIGame(difficulty);
}

function placeMark(cell, mark) {
    moveHistory.push(cells.indexOf(cell));
    cell.textContent = mark;
    cell.classList.remove('empty');

    // Handle fading and removal of old moves
    if (moveHistory.length >= 5) {
        const fadeIndex = moveHistory[moveHistory.length - 5];
        cells[fadeIndex].classList.add('faded');
    }
    if (moveHistory.length >= 6) {
        const removeIndex = moveHistory.shift();
        board[removeIndex] = null;
        cells[removeIndex].textContent = '';
        cells[removeIndex].classList.remove('faded');
        cells[removeIndex].classList.add('empty');
    }
}

function isBoardFull(board) {
    return !board.includes(null);
}

function checkWinCondition(board) {
    const winningCombos = [
        [0, 1, 2], [3, 4, 5], [6, 7, 8],
        [0, 3, 6], [1, 4, 7], [2, 5, 8],
        [0, 4, 8], [2, 4, 6]
    ];
    
    for (const [a, b, c] of winningCombos) {
        if (board[a] && board[a] === board[b] && board[a] === board[c]) {
            return true;
        }
    }
    return false;
}

function goHome() {
    location.reload();
}

function createRoom() {
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ type: 'createRoom' }));
    }
}

function showJoinRoom() {
    if (socket && socket.readyState === WebSocket.OPEN) {
        document.getElementById('joinRoomPanel').style.display = 'flex';
    }
}

function joinRoom() {
    const roomCodeValue = document.getElementById('roomCodeInput').value.trim().toUpperCase();
    if (!roomCodeValue) {
        alert('Please enter a room code');
        return;
    }
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ 
            type: 'join', // Corrected message type
            roomCode: roomCodeValue
        }));
        queueInfo.textContent = 'Joining room...';
    }
}

function copyRoomCode() {
    const code = document.getElementById('displayedRoomCode').textContent;
    navigator.clipboard.writeText(code).then(() => {
        queueInfo.textContent = 'Room code copied to clipboard!';
        setTimeout(() => queueInfo.textContent = '', 2000);
    });
}

function restartGame() {
    resetGame();
    modeSelect.style.display = 'block';
    aiSettings.style.display = 'none';
    onlineSettings.style.display = 'none';
    if (socket) {
        socket.close();
        socket = null;
    }
}

// Start in local 2-player mode
window.onload = function() {
    document.getElementById('gameContainer').style.display = 'none';
    // By default, show mode selection
    modeSelect.style.display = 'flex';

    const footer = document.querySelector('.footer');
    let footerTimeout;

    function hideFooter() {
        footer.classList.add('hidden');
    }

    function showFooter() {
        footer.classList.remove('hidden');
        clearTimeout(footerTimeout);
        footerTimeout = setTimeout(hideFooter, 20000);
    }

    // Initial setup
    footerTimeout = setTimeout(hideFooter, 20000);

    // Show footer on mousemove
    document.addEventListener('mousemove', (e) => {
        if (e.clientY >= window.innerHeight - 60) { // 60px is footer height
            showFooter();
        }
    });

    // Keep footer visible when hovering over it
    footer.addEventListener('mouseenter', () => {
        clearTimeout(footerTimeout);
    });

    footer.addEventListener('mouseleave', () => {
        footerTimeout = setTimeout(hideFooter, 5000); // Hide after 5s when mouse leaves
    });
};
</script>
<div class="footer">
    XO Game Â© 2025 Sophie Wilson<br>
    All rights reserved. Created September 2025.<br>
    A dynamic twist on the classic game of Tic-Tac-Toe
</div>
</body>
</html>
