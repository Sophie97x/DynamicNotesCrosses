<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>XO</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' fill='black'/><path d='M26 6L20 12L14 6L12 8L18 14L12 20L14 22L20 16L26 22L28 20L22 14L28 8Z' fill='lime' stroke='lime' stroke-width='1'/></svg>">
<meta name="theme-color" content="#00ff00">
<style>
:root {
  --grid-size: min(80vw, 400px);
  --cell-size: calc(var(--grid-size) / 3.5);
  --primary-color: #00ff00;
  --primary-glow: 0 0 10px var(--primary-color);
  --intense-glow: 0 0 10px var(--primary-color), 0 0 20px var(--primary-color);
}

body {
  font-family: Arial, sans-serif;
  text-align: center;
  margin: 0;
  padding: 60px 10px; /* Added top padding for home button */
  padding-bottom: 100px; /* More space for footer */
  min-height: 100vh;
  background-color: #000;
  color: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
  box-sizing: border-box;
}

h1 {
  margin-top: 20px;
  margin-bottom: 20px;
  color: var(--primary-color);
  text-shadow: var(--intense-glow);
  font-size: clamp(24px, 5vw, 36px);
}
#modeSelect {
  display: flex !important; /* Force display */
  flex-wrap: wrap;
  gap: 15px;
  justify-content: center;
  margin: 20px auto;
  max-width: var(--grid-size);
  padding: 0 10px;
  z-index: 100;
}

#modeSelect button,
.action-btn,
.home-button {
  padding: 12px 24px;
  font-size: clamp(14px, 3vw, 16px);
  background-color: var(--primary-color);
  color: #000;
  border: 2px solid var(--primary-color);
  border-radius: 5px;
  cursor: pointer;
  box-shadow: var(--primary-glow);
  white-space: nowrap;
  min-width: 140px;
  font-weight: bold;
  transition: all 0.3s ease;
}

#modeSelect button:hover,
.action-btn:hover {
  background-color: transparent;
  color: var(--primary-color);
  box-shadow: var(--intense-glow);
}

.header-container {
  position: relative;
  width: 100%;
  padding: 10px;
  margin-bottom: 20px;
}

.home-button {
  position: absolute;
  top: 20px;
  left: 20px;
  padding: 8px 16px;
  font-size: 14px;
  z-index: 1000;
}

h1 {
  margin: 60px auto 20px auto;
}

@media (max-width: 600px) {
  .home-button {
    position: absolute;
    top: 10px;
    left: 10px;
  }
  
  h1 {
    font-size: 24px;
    margin: 50px auto 15px auto;
  }
  
  .grid {
    margin-top: 10px;
  }
}

.home-button:hover,
#modeSelect button:hover,
.action-btn:hover {
  background-color: #004d00;
  color: #fff;
}

.room-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  justify-content: center;
  margin: 10px;
}

.room-join-container {
  display: none;
  gap: 10px;
  justify-content: center;
  margin: 10px;
  flex-wrap: wrap;
}
.room-code-input {
  padding: 10px;
  font-size: 16px;
  border: 2px solid #00ff00;
  border-radius: 5px;
  background: #111;
  color: #00ff00;
  outline: none;
}
.room-code-input:focus {
  box-shadow: 0 0 10px #00ff00;
}
.start-button {
  padding: 10px 20px;
  font-size: 16px;
  background-color: #00ff00;
  color: #000;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  box-shadow: 0 0 10px #00ff00;
}
.start-button:hover {
  background-color: #004d00;
  color: #fff;
}
.room-code-display {
  margin: 10px;
  padding: 10px;
  background: #111;
  border: 1px solid #00ff00;
  border-radius: 5px;
  display: inline-block;
}
.grid {
  display: grid;
  grid-template-columns: repeat(3, var(--cell-size));
  gap: min(15px, 3vw);
  margin: 20px auto;
  width: var(--grid-size);
}

.cell {
  width: var(--cell-size);
  height: var(--cell-size);
  background: linear-gradient(145deg, #111, #222);
  border: 2px solid var(--primary-color);
  border-radius: min(10px, 2vw);
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: clamp(24px, 8vw, 40px);
  font-weight: bold;
  color: var(--primary-color);
  text-shadow: var(--intense-glow);
  cursor: pointer;
  box-shadow: var(--primary-glow), inset 0 0 10px #004d00;
  transition: all 0.3s ease;
}
.cell:hover {
  background: #004d00;
  box-shadow: 0 0 20px #00ff00, inset 0 0 15px #00ff00;
}
.cell.faded {
  opacity: 0.5;
  text-shadow: 0 0 5px #00ff00;
}
.cell.empty {
  color: transparent;
  text-shadow: none;
}
.win-screen {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  color: #00ff00;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  z-index: 1000;
  text-align: center;
}
.win-screen h2 {
  font-size: 50px;
  margin-bottom: 20px;
  text-shadow: 0 0 15px #00ff00;
}
.win-screen button {
  padding: 10px 20px;
  font-size: 20px;
  color: #000;
  background-color: #00ff00;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  box-shadow: 0 0 10px #00ff00;
}
.win-screen button:hover {
  background-color: #004d00;
  color: #fff;
}
.footer {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  padding: 15px 5px;
  background-color: rgba(0, 0, 0, 0.95);
  color: var(--primary-color);
  text-align: center;
  font-size: clamp(11px, 2.5vw, 14px);
  text-shadow: var(--primary-glow);
  backdrop-filter: blur(5px);
  z-index: 1000;
  line-height: 1.6;
  border-top: 1px solid rgba(0, 255, 0, 0.2);
  transition: opacity 0.5s ease-in-out;
  opacity: 1;
}

.footer.hidden {
  opacity: 0;
  pointer-events: none;
}

.footer:hover {
  opacity: 1;
  pointer-events: auto;
}
</style>
</head>
<body>
<div class="header-container">
  <button class="home-button" onclick="goHome()">Home</button>
  <h1>Dynamic Notes and Crosses</h1>
</div>
<div id="modeSelect">
  <button onclick="selectMode('local')">Local 2-Player</button>
  <button onclick="selectMode('ai')">Play vs AI</button>
  <button onclick="selectMode('online')">Online Multiplayer</button>
</div>

<div id="aiSettings" style="display:none; margin:10px;">
  <label>AI Difficulty: 
    <select id="aiDifficulty">
      <option value="easy">Easy</option>
      <option value="medium">Medium</option>
      <option value="hard">Hard</option>
    </select>
  </label>
  <button onclick="startAIGame()">Start Game</button>
</div>

<div id="onlineSettings" style="display:none; margin:10px;">
  <div class="room-buttons">
    <button onclick="findRandomMatch()" class="action-btn">Find Random Match</button>
    <button onclick="createRoom()" class="action-btn">Create Room</button>
    <button onclick="showJoinRoom()" class="action-btn">Join Room</button>
  </div>
  <div id="roomCodeDisplay" class="room-code-display" style="display:none">
    Room Code: <span id="displayedRoomCode"></span>
    <button onclick="copyRoomCode()" class="action-btn">Copy Code</button>
  </div>
  <div id="joinRoomPanel" class="room-join-container">
    <input type="text" class="room-code-input" id="roomCodeInput" placeholder="Enter Room Code">
    <button class="start-button" onclick="joinRoom()">Start</button>
  </div>
  <span id="queueInfo"></span>
  <div id="onlineStatus" style="margin-top:10px;">
    <div>Players Online: <span id="playersOnline">0</span></div>
    <div>In Queue: <span id="playersInQueue">0</span></div>
    <div id="roomInfo"></div>
  </div>
</div>

<div class="grid" id="gameGrid">
  <div class="cell empty" data-cell></div>
  <div class="cell empty" data-cell></div>
  <div class="cell empty" data-cell></div>
  <div class="cell empty" data-cell></div>
  <div class="cell empty" data-cell></div>
  <div class="cell empty" data-cell></div>
  <div class="cell empty" data-cell></div>
  <div class="cell empty" data-cell></div>
  <div class="cell empty" data-cell></div>
</div>
<div class="win-screen" id="winScreen" style="display: none; flex-direction: column;">
  <h2 id="winnerText"></h2>
  <button onclick="restartGame()">Restart</button>
</div>
<div id="onlineUI" style="display:none; margin:10px;">
  <button onclick="findRandomMatch()">Random Match</button>
  <input id="roomInput" placeholder="Room ID" style="width:100px;"/>
  <button onclick="joinRoom()">Join Room</button>
  <div id="onlineStatus"></div>
  <div id="queueInfo"></div>
  <div id="roomInfo"></div>
</div>
<script>
// DOM elements
const grid = document.getElementById('gameGrid');
const cells = Array.from(document.querySelectorAll('[data-cell]'));
const winScreen = document.getElementById('winScreen');
const winnerText = document.getElementById('winnerText');
const modeSelect = document.getElementById('modeSelect');
const aiSettings = document.getElementById('aiSettings');
const onlineSettings = document.getElementById('onlineSettings');
const queueInfo = document.getElementById('queueInfo');
const playersOnline = document.getElementById('playersOnline');
const playersInQueue = document.getElementById('playersInQueue');
const roomInfo = document.getElementById('roomInfo');

// Game state
let board = Array(9).fill(null);
let moveHistory = [];
let moveCount = 0;
let currentMode = null;
let currentTurn = 'X';
let socket = null;
let roomCode = null;
let playerMark = null; // 'X' or 'O' in multiplayer

// Game logic
function selectMode(mode) {
    // Reset any ongoing game
    resetGame();
    currentMode = mode;
    
    // Hide all settings panels first
    aiSettings.style.display = 'none';
    onlineSettings.style.display = 'none';
    
    // Setup based on selected mode
    if (mode === 'local') {
        setupLocalGame();
    } else if (mode === 'ai') {
        aiSettings.style.display = 'block';
    } else if (mode === 'online') {
        onlineSettings.style.display = 'block';
        setupOnlineGame();
    }
}

function setupLocalGame() {
    resetGame();
    currentTurn = 'X';
    cells.forEach(cell => {
        cell.addEventListener('click', handleLocalMove);
    });
}

function setupAIGame(difficulty) {
    resetGame();
    currentTurn = 'X';
    cells.forEach(cell => {
        cell.addEventListener('click', handlePlayerVsAIMove);
    });
}

function setupOnlineGame() {
    resetGame();
    
    // Remove all existing event listeners
    cells.forEach(cell => {
        cell.removeEventListener('click', handleOnlineMove);
        cell.removeEventListener('click', handleLocalMove);
        cell.removeEventListener('click', handlePlayerVsAIMove);
    });
    
    // Clean up any existing socket
    if (socket) {
        socket.close();
        socket = null;
    }
    
    // Connect to WebSocket
    let wsUrl;
    const hostname = window.location.hostname;
    const isLocal = hostname === 'localhost' || hostname.startsWith('192.168.');
    
    if (isLocal) {
        // Local development
        wsUrl = 'ws://localhost:8080/ws';
    } else {
        // Production (xo.sophiewilson.site)
        wsUrl = 'wss://xo.sophiewilson.site:8080/ws';  // Use explicit port for WebSocket
    }
    
    console.log('Connecting to WebSocket at:', wsUrl);
    
    let connectTimeout;
    
    let retryCount = 0;
    const maxRetries = 3;
    
    function connectWebSocket() {
        try {
            if (socket && socket.readyState !== WebSocket.CLOSED) {
                socket.close();
            }
            
            socket = new WebSocket(wsUrl);
            
            // Set up connection timeout before any event handlers
            connectTimeout = setTimeout(() => {
                if (socket && socket.readyState !== WebSocket.OPEN) {
                    console.error('WebSocket connection timed out');
                    if (roomInfo) roomInfo.textContent = 'Connection timed out. Retrying...';
                    retryConnection();
                }
            }, 5000);
            
            socket.onopen = () => {
                clearTimeout(connectTimeout);  // Clear timeout on successful connection
                console.log('WebSocket connected successfully');
                retryCount = 0;  // Reset retry count on successful connection
                if (roomInfo) roomInfo.textContent = 'Connected to server';
            // Wait a short moment to ensure the connection is fully established
            setTimeout(() => {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({ type: 'getStats' }));
                }
            }, 100);
        };
        
        socket.onclose = (event) => {
            clearTimeout(connectTimeout);  // Clear timeout on close
            console.log('WebSocket disconnected:', event.code, event.reason);
            if (roomInfo) roomInfo.textContent = 'Disconnected from server. Retrying...';
            retryConnection();
        };
        
        socket.onerror = (error) => {
            clearTimeout(connectTimeout);  // Clear timeout on error
            console.error('WebSocket error:', error);
            if (roomInfo) roomInfo.textContent = 'Connection error. Retrying...';
            // Error will trigger onclose, so no need to retry here
        };
        
        function retryConnection() {
            if (retryCount < maxRetries) {
                retryCount++;
                console.log(`Retrying connection (${retryCount}/${maxRetries})...`);
                setTimeout(connectWebSocket, 2000 * retryCount); // Exponential backoff
            } else {
                console.error('Max retry attempts reached');
                if (roomInfo) roomInfo.textContent = 'Could not connect to server. Please try again later.';
            }
        }
        
        socket.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                handleServerMessage(data);
            } catch (err) {
                console.error('Error handling message:', err);
            }
        };
        
    } catch (err) {
        clearTimeout(connectTimeout);  // Clear timeout on error
        console.error('Failed to create WebSocket:', err);
        if (roomInfo) roomInfo.textContent = 'Failed to connect to server';
    }
    
    connectWebSocket();
}

function connectWebSocket() {
    try {
        socket = new WebSocket(wsUrl);
        
        socket.onopen = () => {
            clearTimeout(connectTimeout);
            console.log('WebSocket connected successfully');
            roomInfo.textContent = 'Connected to server';
            // Request initial stats
            socket.send(JSON.stringify({ type: 'getStats' }));
        };
        
        socket.onclose = () => {
            console.log('WebSocket connection closed');
            roomInfo.textContent = 'Disconnected from server';
        };
        
        socket.onerror = (error) => {
            console.error('WebSocket error:', error);
            roomInfo.textContent = 'Connection error. Please try again.';
            clearTimeout(connectTimeout);
        };

        // Setup message handler
        socket.onmessage = (event) => {
            const data = JSON.parse(event.data);
            handleServerMessage(data);
        };
        
    } catch (err) {
        console.error('WebSocket creation failed:', err);
        roomInfo.textContent = 'Failed to connect to game server. Please try again.';
        clearTimeout(connectTimeout);
    }
    
    socket.onopen = () => {
        console.log('Connected to game server');
        roomInfo.textContent = 'Connected to server';
        // Request initial stats
        socket.send(JSON.stringify({ type: 'getStats' }));
    };
    
    // Reset game state
    currentTurn = 'X';
    playerMark = null; // Will be set when matched
    
    socket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        handleServerMessage(data);
    };
    
    socket.onclose = () => {
        roomInfo.textContent = 'Disconnected from server';
    };

    // Request available rooms when socket connects
    socket.onopen = () => {
        socket.send(JSON.stringify({ type: 'getRooms' }));
    };
}

function updateAvailableRooms(rooms) {
    const roomsDiv = document.getElementById('availableRooms');
    if (!roomsDiv) return;

    roomsDiv.innerHTML = '';
    if (!rooms || rooms.length === 0) {
        roomsDiv.innerHTML = '<p>No rooms available</p>';
        return;
    }

    rooms.forEach(room => {
        const button = document.createElement('button');
        button.className = 'action-btn';
        button.textContent = `Join Room ${room}`;
        button.onclick = () => joinRoom(room);
        roomsDiv.appendChild(button);
    });
}

function handleServerMessage(data) {
    if (!data || !data.type) return;
    
    console.log('Received server message:', data.type);
    
    switch(data.type) {
        case 'stats':
            if (playersOnline) playersOnline.textContent = data.playersOnline || 0;
            if (playersInQueue) playersInQueue.textContent = data.playersInQueue || 0;
            break;
        case 'matched':
            roomCode = data.roomCode;
            playerMark = data.playerMark;
            currentTurn = 'X'; // Game always starts with X
            
            // Remove existing event listeners first
            cells.forEach(cell => {
                cell.removeEventListener('click', handleOnlineMove);
                cell.removeEventListener('click', handleLocalMove);
                cell.removeEventListener('click', handlePlayerVsAIMove);
            });
            
            // Add online move event listeners
            cells.forEach(cell => {
                cell.addEventListener('click', handleOnlineMove);
            });
            
            // Update turn info based on player's mark
            const turnMessage = playerMark === 'X' ? "It's your turn!" : "Waiting for opponent's move...";
            if (roomInfo) roomInfo.textContent = `Room: ${roomCode} - You are ${playerMark} - ${turnMessage}`;
            console.log('Game started. You are:', playerMark, 'Current turn:', currentTurn);
            
            const displayedRoomCode = document.getElementById('displayedRoomCode');
            const roomCodeDisplay = document.getElementById('roomCodeDisplay');
            const joinRoomPanel = document.getElementById('joinRoomPanel');
            
            if (displayedRoomCode) displayedRoomCode.textContent = roomCode;
            if (roomCodeDisplay) roomCodeDisplay.style.display = 'inline-block';
            if (joinRoomPanel) joinRoomPanel.style.display = 'none';
            
            cells.forEach(cell => cell.addEventListener('click', handleOnlineMove));
            break;
        case 'roomCreated':
            roomCode = data.roomCode;
            const displayCode = document.getElementById('displayedRoomCode');
            const codeDisplay = document.getElementById('roomCodeDisplay');
            
            if (displayCode) displayCode.textContent = roomCode;
            if (codeDisplay) codeDisplay.style.display = 'inline-block';
            if (queueInfo) queueInfo.textContent = 'Waiting for opponent to join...';
            break;
        case 'availableRooms':
            updateAvailableRooms(data.rooms);
            break;
        case 'move':
            if (typeof handleOpponentMove === 'function') {
                handleOpponentMove(data.position);
            }
            break;
        case 'queue':
            if (queueInfo) queueInfo.textContent = 'Waiting for opponent...';
            break;
        case 'roomFull':
            if (queueInfo) queueInfo.textContent = 'Room is full. Please try another room.';
            break;
    }
}

function handleLocalMove(e) {
    const cell = e.target;
    const index = cells.indexOf(cell);
    
    if (cell.textContent || !cell.classList.contains('empty')) return;
    
    moveCount++;
    currentTurn = moveCount % 2 === 0 ? 'O' : 'X';
    board[index] = currentTurn;
    
    // Update display
    cell.textContent = currentTurn;
    cell.classList.remove('empty');
    
    // Handle history
    moveHistory.push(index);
    if (moveHistory.length >= 5) {
        const fadeIndex = moveHistory[moveHistory.length - 5];
        if (fadeIndex >= 0) {
            cells[fadeIndex].classList.add('faded');
        }
    }
    if (moveHistory.length >= 6) {
        const oldestIndex = moveHistory.shift();
        board[oldestIndex] = null;
        cells[oldestIndex].textContent = '';
        cells[oldestIndex].classList.remove('faded');
        cells[oldestIndex].classList.add('empty');
    }
    
    checkWin();
}

function checkWin() {
    const winningCombos = [
        [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
        [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
        [0, 4, 8], [2, 4, 6] // diagonals
    ];
    
    for (const combo of winningCombos) {
        const [a, b, c] = combo;
        if (board[a] && board[a] === board[b] && board[a] === board[c]) {
            showWin(board[a]);
            return;
        }
    }
}

function showWin(winner) {
    winnerText.textContent = `${winner} Wins!`;
    winScreen.style.display = 'flex';
}

function resetGame() {
    board = Array(9).fill(null);
    moveHistory = [];
    moveCount = 0;
    cells.forEach(cell => {
        cell.textContent = '';
        cell.classList.remove('faded');
        cell.classList.add('empty');
    });
    winScreen.style.display = 'none';
}

// AI Game Logic
function handlePlayerVsAIMove(e) {
    if (currentTurn !== 'X') return; // Wait for player's turn
    
    const cell = e.target;
    const index = cells.indexOf(cell);
    
    if (cell.textContent || !cell.classList.contains('empty')) return;
    
    // Player move
    board[index] = 'X';
    placeMark(cell, 'X');
    currentTurn = 'O';
    
    if (!checkWin()) {
        // AI move
        setTimeout(() => {
            const aiMove = calculateAIMove(board, aiDifficulty.value);
            board[aiMove] = 'O';
            placeMark(cells[aiMove], 'O');
            currentTurn = 'X';
            checkWin();
        }, 500);
    }
}

function calculateAIMove(board, difficulty) {
    if (difficulty === 'easy') {
        // Random empty spot
        const emptyCells = board.map((val, idx) => val ? null : idx).filter(val => val !== null);
        return emptyCells[Math.floor(Math.random() * emptyCells.length)];
    } else if (difficulty === 'medium') {
        // Block winning moves or take winning moves, otherwise random
        const winMove = findWinningMove(board, 'O');
        if (winMove !== null) return winMove;
        
        const blockMove = findWinningMove(board, 'X');
        if (blockMove !== null) return blockMove;
        
        return calculateAIMove(board, 'easy');
    } else {
        // Hard: Use minimax
        return findBestMove(board);
    }
}

function findWinningMove(board, mark) {
    for (let i = 0; i < 9; i++) {
        if (!board[i]) {
            board[i] = mark;
            if (checkWinCondition(board)) {
                board[i] = null;
                return i;
            }
            board[i] = null;
        }
    }
    return null;
}

function findBestMove(board) {
    let bestScore = -Infinity;
    let bestMove = null;
    
    for (let i = 0; i < 9; i++) {
        if (!board[i]) {
            board[i] = 'O';
            let score = minimax(board, 0, false);
            board[i] = null;
            if (score > bestScore) {
                bestScore = score;
                bestMove = i;
            }
        }
    }
    
    return bestMove;
}

function minimax(board, depth, isMaximizing) {
    if (checkWinCondition(board)) {
        return isMaximizing ? -1 : 1;
    }
    if (isBoardFull(board)) {
        return 0;
    }
    
    if (isMaximizing) {
        let bestScore = -Infinity;
        for (let i = 0; i < 9; i++) {
            if (!board[i]) {
                board[i] = 'O';
                let score = minimax(board, depth + 1, false);
                board[i] = null;
                bestScore = Math.max(score, bestScore);
            }
        }
        return bestScore;
    } else {
        let bestScore = Infinity;
        for (let i = 0; i < 9; i++) {
            if (!board[i]) {
                board[i] = 'X';
                let score = minimax(board, depth + 1, true);
                board[i] = null;
                bestScore = Math.min(score, bestScore);
            }
        }
        return bestScore;
    }
}

// Online Game Logic
function findRandomMatch() {
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ type: 'queue' }));
        queueInfo.textContent = 'Finding a match...';
    }
}

function joinRoom() {
    const code = document.getElementById('roomCode').value;
    if (code && socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ type: 'join', roomCode: code }));
        roomInfo.textContent = 'Joining room...';
    }
}

function handleOnlineMove(e) {
    e.preventDefault();  // Prevent any default behavior
    
    if (!socket || socket.readyState !== WebSocket.OPEN) {
        console.log('No active WebSocket connection');
        return;
    }
    
    // Check if it's this player's turn
    if (currentTurn !== playerMark) {
        console.log('Not your turn! Current turn:', currentTurn, 'Your mark:', playerMark);
        if (roomInfo) roomInfo.textContent = `Room: ${roomCode} - You are ${playerMark} - Wait for your turn!`;
        e.stopPropagation();  // Stop event from bubbling
        return;
    }
    
    const cell = e.target;
    const index = cells.indexOf(cell);
    
    // Validate move
    if (cell.textContent || !cell.classList.contains('empty') || board[index]) return;
    
    // Make the move locally first
    board[index] = playerMark;
    placeMark(cell, playerMark);
    
    // Then send to opponent
    socket.send(JSON.stringify({
        type: 'move',
        position: index,
        roomCode: roomCode
    }));
    
    // Switch turns
    currentTurn = currentTurn === 'X' ? 'O' : 'X';
    roomInfo.textContent = `Room: ${roomCode} - You are ${playerMark} - ${currentTurn}'s Turn`;
    checkWin();
}

function handleOpponentMove(position) {
    if (position >= 0 && position < 9 && cells[position].classList.contains('empty')) {
        const opponentMark = playerMark === 'X' ? 'O' : 'X';  // Determine opponent's mark based on player's mark
        board[position] = opponentMark;
        placeMark(cells[position], opponentMark);
        currentTurn = playerMark;  // After opponent moves, it's player's turn
        console.log('Opponent moved, now its your turn. Current turn:', currentTurn, 'Your mark:', playerMark);
        if (roomInfo) roomInfo.textContent = `Room: ${roomCode} - You are ${playerMark} - It's your turn!`;
        checkWin();
    }
}

// UI Helpers
function startAIGame() {
    const difficulty = document.getElementById('aiDifficulty').value;
    aiSettings.style.display = 'none';
    setupAIGame(difficulty);
}

function placeMark(cell, mark) {
    moveHistory.push(cells.indexOf(cell));
    cell.textContent = mark;
    cell.classList.remove('empty');

    // Handle fading and removal of old moves
    if (moveHistory.length >= 5) {
        const fadeIndex = moveHistory[moveHistory.length - 5];
        cells[fadeIndex].classList.add('faded');
    }
    if (moveHistory.length >= 6) {
        const removeIndex = moveHistory.shift();
        board[removeIndex] = null;
        cells[removeIndex].textContent = '';
        cells[removeIndex].classList.remove('faded');
        cells[removeIndex].classList.add('empty');
    }
}

function isBoardFull(board) {
    return !board.includes(null);
}

function checkWinCondition(board) {
    const winningCombos = [
        [0, 1, 2], [3, 4, 5], [6, 7, 8],
        [0, 3, 6], [1, 4, 7], [2, 5, 8],
        [0, 4, 8], [2, 4, 6]
    ];
    
    for (const [a, b, c] of winningCombos) {
        if (board[a] && board[a] === board[b] && board[a] === board[c]) {
            return true;
        }
    }
    return false;
}

function goHome() {
    location.reload();
}

function createRoom() {
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ type: 'createRoom' }));
    }
}

function showJoinRoom() {
    if (socket && socket.readyState === WebSocket.OPEN) {
        document.getElementById('joinRoomPanel').style.display = 'flex';
    }
}

function joinRoom() {
    const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
    if (!roomCode) {
        alert('Please enter a room code');
        return;
    }
    if (socket && socket.readyState === WebSocket.OPEN) {
        // Remove any existing click handlers
        cells.forEach(cell => {
            cell.removeEventListener('click', handleOnlineMove);
            cell.removeEventListener('click', handleLocalMove);
            cell.removeEventListener('click', handlePlayerVsAIMove);
        });
        
        // Reset the game state
        resetGame();
        
        // Send join request
        socket.send(JSON.stringify({ 
            type: 'joinRoom',
            roomCode: roomCode
        }));
        
        // Update UI
        document.getElementById('roomCodeInput').value = '';
        document.getElementById('joinRoomPanel').style.display = 'none';
        queueInfo.textContent = 'Joining room...';
        
        // Add click handlers for online play
        cells.forEach(cell => cell.addEventListener('click', handleOnlineMove));
    }
}

function copyRoomCode() {
    const code = document.getElementById('displayedRoomCode').textContent;
    navigator.clipboard.writeText(code).then(() => {
        queueInfo.textContent = 'Room code copied to clipboard!';
        setTimeout(() => queueInfo.textContent = '', 2000);
    });
}

function restartGame() {
    resetGame();
    modeSelect.style.display = 'block';
    aiSettings.style.display = 'none';
    onlineSettings.style.display = 'none';
    if (socket) {
        socket.close();
        socket = null;
    }
}

// Start in local 2-player mode and handle footer
window.onload = function() {
    // Make sure modeSelect is visible and aiSettings/onlineSettings are hidden
    modeSelect.style.display = 'flex';
    aiSettings.style.display = 'none';
    onlineSettings.style.display = 'none';
    
    // Start with local 2-player mode
    selectMode('local');
    
    // Footer auto-hide
    const footer = document.querySelector('.footer');
    let footerTimeout;

    function showFooter() {
        footer.classList.remove('hidden');
    }

    function hideFooter() {
        footer.classList.add('hidden');
    }

    function resetFooterTimer() {
        clearTimeout(footerTimeout);
        showFooter();
        footerTimeout = setTimeout(hideFooter, 20000); // 20 seconds
    }

    // Initial timer
    resetFooterTimer();

    // Show on hover
    footer.addEventListener('mouseenter', () => {
        clearTimeout(footerTimeout);
        showFooter();
    });

    // Reset timer on mouse leave
    footer.addEventListener('mouseleave', resetFooterTimer);
};
</script>
<div class="footer">
    XO Game Â© 2025 Sophie Wilson<br>
    All rights reserved. Created September 2025.<br>
    A dynamic twist on the classic game of Tic-Tac-Toe
</div>
</body>
</html>
