<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dynamic Notes and Crosses</title>
<style>
body {
  font-family: Arial, sans-serif;
  text-align: center;
  margin: 0;
  padding: 0;
  background-color: #000;
  color: #fff;
}
h1 {
  margin-top: 20px;
  color: #00ff00;
  text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00;
}
.home-button {
  position: fixed;
  top: 20px;
  left: 20px;
  padding: 10px 20px;
  font-size: 16px;
  background-color: #00ff00;
  color: #000;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  box-shadow: 0 0 10px #00ff00;
  z-index: 1000;
}
.home-button:hover {
  background-color: #004d00;
  color: #fff;
}
.room-buttons {
  display: flex;
  gap: 10px;
  justify-content: center;
  margin: 10px;
}
.room-join-container {
  display: none;
  gap: 10px;
  justify-content: center;
  margin: 10px;
}
.room-code-input {
  padding: 10px;
  font-size: 16px;
  border: 2px solid #00ff00;
  border-radius: 5px;
  background: #111;
  color: #00ff00;
  outline: none;
}
.room-code-input:focus {
  box-shadow: 0 0 10px #00ff00;
}
.start-button {
  padding: 10px 20px;
  font-size: 16px;
  background-color: #00ff00;
  color: #000;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  box-shadow: 0 0 10px #00ff00;
}
.start-button:hover {
  background-color: #004d00;
  color: #fff;
}
.room-code-display {
  margin: 10px;
  padding: 10px;
  background: #111;
  border: 1px solid #00ff00;
  border-radius: 5px;
  display: inline-block;
}
.grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 15px;
  margin: 40px auto;
  width: 300px;
}
.cell {
  width: 100px;
  height: 100px;
  background: linear-gradient(145deg, #111, #222);
  border: 2px solid #00ff00;
  border-radius: 10px;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 40px;
  font-weight: bold;
  color: #00ff00;
  text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00;
  cursor: pointer;
  box-shadow: 0 0 15px #00ff00, inset 0 0 10px #004d00;
  transition: all 0.3s ease;
}
.cell:hover {
  background: #004d00;
  box-shadow: 0 0 20px #00ff00, inset 0 0 15px #00ff00;
}
.cell.faded {
  opacity: 0.5;
  text-shadow: 0 0 5px #00ff00;
}
.cell.empty {
  color: transparent;
  text-shadow: none;
}
.win-screen {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  color: #00ff00;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  z-index: 1000;
  text-align: center;
}
.win-screen h2 {
  font-size: 50px;
  margin-bottom: 20px;
  text-shadow: 0 0 15px #00ff00;
}
.win-screen button {
  padding: 10px 20px;
  font-size: 20px;
  color: #000;
  background-color: #00ff00;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  box-shadow: 0 0 10px #00ff00;
}
.win-screen button:hover {
  background-color: #004d00;
  color: #fff;
}
</style>
</head>
<body>
<button class="home-button" onclick="goHome()">Home</button>
<h1>Dynamic Notes and Crosses</h1>
<div id="modeSelect">
  <button onclick="selectMode('local')">Local 2-Player</button>
  <button onclick="selectMode('ai')">Play vs AI</button>
  <button onclick="selectMode('online')">Online Multiplayer</button>
</div>

<div id="aiSettings" style="display:none; margin:10px;">
  <label>AI Difficulty: 
    <select id="aiDifficulty">
      <option value="easy">Easy</option>
      <option value="medium">Medium</option>
      <option value="hard">Hard</option>
    </select>
  </label>
  <button onclick="startAIGame()">Start Game</button>
</div>

<div id="onlineSettings" style="display:none; margin:10px;">
  <div class="room-buttons">
    <button onclick="findRandomMatch()" class="action-btn">Find Random Match</button>
    <button onclick="createRoom()" class="action-btn">Create Room</button>
    <button onclick="showJoinRoom()" class="action-btn">Join Room</button>
  </div>
  <div id="roomCodeDisplay" class="room-code-display" style="display:none">
    Room Code: <span id="displayedRoomCode"></span>
    <button onclick="copyRoomCode()" class="action-btn">Copy Code</button>
  </div>
  <div id="joinRoomPanel" class="room-join-container">
    <input type="text" class="room-code-input" id="roomCodeInput" placeholder="Enter Room Code">
    <button class="start-button" onclick="joinRoom()">Start</button>
  </div>
  <span id="queueInfo"></span>
  <div id="onlineStatus" style="margin-top:10px;">
    <div>Players Online: <span id="playersOnline">0</span></div>
    <div>In Queue: <span id="playersInQueue">0</span></div>
    <div id="roomInfo"></div>
  </div>
</div>

<div class="grid" id="gameGrid">
  <div class="cell empty" data-cell></div>
  <div class="cell empty" data-cell></div>
  <div class="cell empty" data-cell></div>
  <div class="cell empty" data-cell></div>
  <div class="cell empty" data-cell></div>
  <div class="cell empty" data-cell></div>
  <div class="cell empty" data-cell></div>
  <div class="cell empty" data-cell></div>
  <div class="cell empty" data-cell></div>
</div>
<div class="win-screen" id="winScreen" style="display: none; flex-direction: column;">
  <h2 id="winnerText"></h2>
  <button onclick="restartGame()">Restart</button>
</div>
<div id="onlineUI" style="display:none; margin:10px;">
  <button onclick="findRandomMatch()">Random Match</button>
  <input id="roomInput" placeholder="Room ID" style="width:100px;"/>
  <button onclick="joinRoom()">Join Room</button>
  <div id="onlineStatus"></div>
  <div id="queueInfo"></div>
  <div id="roomInfo"></div>
</div>
<script>
// Game state
let board = Array(9).fill(null);
let moveHistory = [];
let moveCount = 0;
let currentMode = null;
let currentTurn = 'X';
let socket = null;
let roomCode = null;
let playerMark = null; // 'X' or 'O' in multiplayer

// DOM elements
const grid = document.getElementById('gameGrid');
const cells = Array.from(document.querySelectorAll('[data-cell]'));
const winScreen = document.getElementById('winScreen');
const winnerText = document.getElementById('winnerText');
const modeSelect = document.getElementById('modeSelect');
const aiSettings = document.getElementById('aiSettings');
const onlineSettings = document.getElementById('onlineSettings');
const queueInfo = document.getElementById('queueInfo');
const playersOnline = document.getElementById('playersOnline');
const playersInQueue = document.getElementById('playersInQueue');
const roomInfo = document.getElementById('roomInfo');

// Game logic
function selectMode(mode) {
    currentMode = mode;
    modeSelect.style.display = 'none';
    aiSettings.style.display = 'none';
    onlineSettings.style.display = 'none';
    
    if (mode === 'local') {
        setupLocalGame();
    } else if (mode === 'ai') {
        aiSettings.style.display = 'block';
    } else if (mode === 'online') {
        onlineSettings.style.display = 'block';
        setupOnlineGame();
    }
}

function setupLocalGame() {
    resetGame();
    currentTurn = 'X';
    cells.forEach(cell => {
        cell.addEventListener('click', handleLocalMove);
    });
}

function setupAIGame(difficulty) {
    resetGame();
    currentTurn = 'X';
    cells.forEach(cell => {
        cell.addEventListener('click', handlePlayerVsAIMove);
    });
}

function setupOnlineGame() {
    resetGame();
    // Connect to WebSocket
    const wsUrl = `${window.location.origin.replace(/^http/, 'ws')}/ws`;
    console.log('Connecting to WebSocket at:', wsUrl);
    // Add error handling for connection issues
    try {
        socket = new WebSocket(wsUrl);
    } catch (err) {
        console.error('WebSocket connection failed:', err);
        roomInfo.textContent = 'Failed to connect to game server. Please try again.';
    }
    
    socket.onopen = () => {
        console.log('Connected to game server');
        roomInfo.textContent = 'Connected to server';
        // Request initial stats
        socket.send(JSON.stringify({ type: 'getStats' }));
    };
    
    // Reset game state
    currentTurn = 'X';
    playerMark = null; // Will be set when matched
    
    socket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        handleServerMessage(data);
    };
    
    socket.onclose = () => {
        roomInfo.textContent = 'Disconnected from server';
    };

    // Request available rooms when socket connects
    socket.onopen = () => {
        socket.send(JSON.stringify({ type: 'getRooms' }));
    };
}

function handleServerMessage(data) {
    switch(data.type) {
        case 'stats':
            playersOnline.textContent = data.playersOnline;
            playersInQueue.textContent = data.playersInQueue;
            break;
        case 'matched':
            roomCode = data.roomCode;
            playerMark = data.playerMark;
            currentTurn = 'X'; // Always start with X
            roomInfo.textContent = `You are ${playerMark} - ${currentTurn}'s Turn`;
            document.getElementById('displayedRoomCode').textContent = roomCode;
            document.getElementById('roomCodeDisplay').style.display = 'inline-block';
            document.getElementById('joinRoomPanel').style.display = 'none';
            cells.forEach(cell => cell.addEventListener('click', handleOnlineMove));
            break;
        case 'roomCreated':
            roomCode = data.roomCode;
            document.getElementById('displayedRoomCode').textContent = roomCode;
            document.getElementById('roomCodeDisplay').style.display = 'inline-block';
            queueInfo.textContent = 'Waiting for opponent to join...';
            break;
        case 'availableRooms':
            updateAvailableRooms(data.rooms);
            break;
        case 'move':
            handleOpponentMove(data.position);
            break;
        case 'queue':
            queueInfo.textContent = 'Waiting for opponent...';
            break;
        case 'roomFull':
            queueInfo.textContent = 'Room is full. Please try another room.';
            break;
    }
}

function handleLocalMove(e) {
    const cell = e.target;
    const index = cells.indexOf(cell);
    
    if (cell.textContent || !cell.classList.contains('empty')) return;
    
    moveCount++;
    currentTurn = moveCount % 2 === 0 ? 'O' : 'X';
    board[index] = currentTurn;
    placeMark(cell, currentTurn);
    
    // Update display
    cell.textContent = mark;
    cell.classList.remove('empty');
    
    // Handle history
    moveHistory.push(index);
    if (moveHistory.length >= 5) {
        const fadeIndex = moveHistory[moveHistory.length - 5];
        if (fadeIndex >= 0) {
            cells[fadeIndex].classList.add('faded');
        }
    }
    if (moveHistory.length >= 6) {
        const oldestIndex = moveHistory.shift();
        board[oldestIndex] = null;
        cells[oldestIndex].textContent = '';
        cells[oldestIndex].classList.remove('faded');
        cells[oldestIndex].classList.add('empty');
    }
    
    checkWin();
}

function checkWin() {
    const winningCombos = [
        [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
        [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
        [0, 4, 8], [2, 4, 6] // diagonals
    ];
    
    for (const combo of winningCombos) {
        const [a, b, c] = combo;
        if (board[a] && board[a] === board[b] && board[a] === board[c]) {
            showWin(board[a]);
            return;
        }
    }
}

function showWin(winner) {
    winnerText.textContent = `${winner} Wins!`;
    winScreen.style.display = 'flex';
}

function resetGame() {
    board = Array(9).fill(null);
    moveHistory = [];
    moveCount = 0;
    cells.forEach(cell => {
        cell.textContent = '';
        cell.classList.remove('faded');
        cell.classList.add('empty');
    });
    winScreen.style.display = 'none';
}

// AI Game Logic
function handlePlayerVsAIMove(e) {
    if (currentTurn !== 'X') return; // Wait for player's turn
    
    const cell = e.target;
    const index = cells.indexOf(cell);
    
    if (cell.textContent || !cell.classList.contains('empty')) return;
    
    // Player move
    board[index] = 'X';
    placeMark(cell, 'X');
    currentTurn = 'O';
    
    if (!checkWin()) {
        // AI move
        setTimeout(() => {
            const aiMove = calculateAIMove(board, aiDifficulty.value);
            board[aiMove] = 'O';
            placeMark(cells[aiMove], 'O');
            currentTurn = 'X';
            checkWin();
        }, 500);
    }
}

function calculateAIMove(board, difficulty) {
    if (difficulty === 'easy') {
        // Random empty spot
        const emptyCells = board.map((val, idx) => val ? null : idx).filter(val => val !== null);
        return emptyCells[Math.floor(Math.random() * emptyCells.length)];
    } else if (difficulty === 'medium') {
        // Block winning moves or take winning moves, otherwise random
        const winMove = findWinningMove(board, 'O');
        if (winMove !== null) return winMove;
        
        const blockMove = findWinningMove(board, 'X');
        if (blockMove !== null) return blockMove;
        
        return calculateAIMove(board, 'easy');
    } else {
        // Hard: Use minimax
        return findBestMove(board);
    }
}

function findWinningMove(board, mark) {
    for (let i = 0; i < 9; i++) {
        if (!board[i]) {
            board[i] = mark;
            if (checkWinCondition(board)) {
                board[i] = null;
                return i;
            }
            board[i] = null;
        }
    }
    return null;
}

function findBestMove(board) {
    let bestScore = -Infinity;
    let bestMove = null;
    
    for (let i = 0; i < 9; i++) {
        if (!board[i]) {
            board[i] = 'O';
            let score = minimax(board, 0, false);
            board[i] = null;
            if (score > bestScore) {
                bestScore = score;
                bestMove = i;
            }
        }
    }
    
    return bestMove;
}

function minimax(board, depth, isMaximizing) {
    if (checkWinCondition(board)) {
        return isMaximizing ? -1 : 1;
    }
    if (isBoardFull(board)) {
        return 0;
    }
    
    if (isMaximizing) {
        let bestScore = -Infinity;
        for (let i = 0; i < 9; i++) {
            if (!board[i]) {
                board[i] = 'O';
                let score = minimax(board, depth + 1, false);
                board[i] = null;
                bestScore = Math.max(score, bestScore);
            }
        }
        return bestScore;
    } else {
        let bestScore = Infinity;
        for (let i = 0; i < 9; i++) {
            if (!board[i]) {
                board[i] = 'X';
                let score = minimax(board, depth + 1, true);
                board[i] = null;
                bestScore = Math.min(score, bestScore);
            }
        }
        return bestScore;
    }
}

// Online Game Logic
function findRandomMatch() {
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ type: 'queue' }));
        queueInfo.textContent = 'Finding a match...';
    }
}

function joinRoom() {
    const code = document.getElementById('roomCode').value;
    if (code && socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ type: 'join', roomCode: code }));
        roomInfo.textContent = 'Joining room...';
    }
}

function handleOnlineMove(e) {
    if (!socket || socket.readyState !== WebSocket.OPEN) return;
    
    // Check if it's this player's turn
    if (currentTurn !== playerMark) {
        roomInfo.textContent = `Room: ${roomCode} - You are ${playerMark} - Wait for your turn!`;
        return;
    }
    
    const cell = e.target;
    const index = cells.indexOf(cell);
    
    // Validate move
    if (cell.textContent || !cell.classList.contains('empty') || board[index]) return;
    
    // Make the move locally first
    board[index] = playerMark;
    placeMark(cell, playerMark);
    
    // Then send to opponent
    socket.send(JSON.stringify({
        type: 'move',
        position: index,
        roomCode: roomCode
    }));
    
    // Switch turns
    currentTurn = currentTurn === 'X' ? 'O' : 'X';
    roomInfo.textContent = `Room: ${roomCode} - You are ${playerMark} - ${currentTurn}'s Turn`;
    checkWin();
}

function handleOpponentMove(position) {
    if (position >= 0 && position < 9 && cells[position].classList.contains('empty')) {
        const opponentMark = currentTurn;  // Use currentTurn as that's the current player's mark
        board[position] = opponentMark;
        placeMark(cells[position], opponentMark);
        currentTurn = currentTurn === 'X' ? 'O' : 'X';
        roomInfo.textContent = `Room: ${roomCode} - You are ${playerMark} - ${currentTurn}'s Turn`;
        checkWin();
    }
}

// UI Helpers
function startAIGame() {
    const difficulty = document.getElementById('aiDifficulty').value;
    aiSettings.style.display = 'none';
    setupAIGame(difficulty);
}

function placeMark(cell, mark) {
    moveHistory.push(cells.indexOf(cell));
    cell.textContent = mark;
    cell.classList.remove('empty');

    // Handle fading and removal of old moves
    if (moveHistory.length >= 5) {
        const fadeIndex = moveHistory[moveHistory.length - 5];
        cells[fadeIndex].classList.add('faded');
    }
    if (moveHistory.length >= 6) {
        const removeIndex = moveHistory.shift();
        board[removeIndex] = null;
        cells[removeIndex].textContent = '';
        cells[removeIndex].classList.remove('faded');
        cells[removeIndex].classList.add('empty');
    }
}

function isBoardFull(board) {
    return !board.includes(null);
}

function checkWinCondition(board) {
    const winningCombos = [
        [0, 1, 2], [3, 4, 5], [6, 7, 8],
        [0, 3, 6], [1, 4, 7], [2, 5, 8],
        [0, 4, 8], [2, 4, 6]
    ];
    
    for (const [a, b, c] of winningCombos) {
        if (board[a] && board[a] === board[b] && board[a] === board[c]) {
            return true;
        }
    }
    return false;
}

function goHome() {
    location.reload();
}

function createRoom() {
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ type: 'createRoom' }));
    }
}

function showJoinRoom() {
    if (socket && socket.readyState === WebSocket.OPEN) {
        document.getElementById('joinRoomPanel').style.display = 'flex';
    }
}

function joinRoom() {
    const roomCode = document.getElementById('roomCodeInput').value.trim();
    if (!roomCode) {
        alert('Please enter a room code');
        return;
    }
    if (socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ 
            type: 'joinRoom',
            roomCode: roomCode
        }));
        document.getElementById('roomCodeInput').value = '';
        document.getElementById('joinRoomPanel').style.display = 'none';
        queueInfo.textContent = 'Joining room...';
        cells.forEach(cell => cell.addEventListener('click', handleOnlineMove));
    }
}

function copyRoomCode() {
    const code = document.getElementById('displayedRoomCode').textContent;
    navigator.clipboard.writeText(code).then(() => {
        queueInfo.textContent = 'Room code copied to clipboard!';
        setTimeout(() => queueInfo.textContent = '', 2000);
    });
}

function restartGame() {
    resetGame();
    modeSelect.style.display = 'block';
    aiSettings.style.display = 'none';
    onlineSettings.style.display = 'none';
    if (socket) {
        socket.close();
        socket = null;
    }
}
</script>
</body>
</html>
